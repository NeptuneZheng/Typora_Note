# Learn About MySQL

#### 1. DB, DBMS, SQL

- **DB**: 数据库(Database): 存储数据的“仓库”。它保存了一系列**有组织的数据**。
- **DBMS**: 数据库管理系统(Database Management System)。数据库是通过DBMS创建和操作的容器。常见的有(基于C/S架构)Oracle，MySQL, DB2, SQLServer ，Access(基于共享文件系统)...
- **SQL**: 结构化查询语言(Structure Query Language)，专门用来与数据库通信的语言。

#### 2. SQL 执行顺序

- 人写顺序

  ![1619438424492](../../media/1619438424492.png)

- 机读

  ![1619438573369](../../media/1619438573369.png)

  ![1619438602083](../../media/1619438602083.png)

  ![1619438950663](../../media/1619438950663.png)

  ![1619439029628](../../media/1619439029628.png)

  

#### 3. 索引

###### A. 优缺点

- 优点:
  - 提高数据检索效率，降低数据库IO成本
  - 通过索引列对数据进行排序，降低数据排序成本，降低CPU消耗
- 缺点:
  - 索引也是一张表，它保存了主键与索引字段，并指向实体记录，也是要占用空间的
  - 虽然索引提高了查询速度，但也降低了表的更新速度。因为在更新时，不仅要保存数据，还要更新添加了索引列的字段
  - 索引是用来提高效率的因素，随着业务等需求的变换，需要花时间研究建立最优秀的索引，或优化查询语句

###### B. 索引分类(一张表原则上最多建5个索引，因为最终使用到的只会是其中一个)

- 单值索引: 一个索引只包含单个列，一个表可以有多个单列索引
- 唯一索引: 索引列的值必须唯一，但允许有空值(**和主键相区别，主键是唯一索引，但不允许空值**)
- 复合索引: 一个索引包含多个列

###### C. 建立索引的原则

![1619441869791](../../media/1619441869791.png)

![1619441920471](../../media/1619441920471.png)

###### D. 性能分析

![1619442166310](../../media/1619442166310.png)

**Explain(执行计划):**

- 使用: explain + SQL

- 执行计划包含的信息:

  ![1619442836427](../../media/1619442836427.png)

  - **id**: select 查询的序列号，为一组数字，表示查询中执行select子句或操作表的顺序。分三种情况:

    - **id 相同**: 执行顺序由上至下
    - **id全不同**: 如果是子查询(`select_type`为***SUBQUERY***),id 的序号会递增，id值越大优先级越高，越先被执行。最后执行普通查询(`select_type`为***PRIMARY***)
    - **id有相同也有不同**: id如果相同可以认为是一组，从上往下执行；在不同组中，id值越大，优先级越高，越先执行

  - **select_type**: 查询的类型，主要是用于区别不同查询的组别(普通查询，联合查询，子查询，复杂查询)。主要由以下几类:

    ![1619443959844](../../media/1619443959844.png)

    ![1619444071714](../../media/1619444071714.png)

    

  - **type**: 显示查询使用了何种类型，**从最好到最差依次是**: **system>const>eq_ref>ref>range>index>ALL**.

    > 一般来说得保证查询至少达到rang级别，最好能达到ref

    ![1619444390947](../../media/1619444390947.png)

    | type     | description                                                  |
    | -------- | ------------------------------------------------------------ |
    | `system` | 表只有一行记录(等于系统表)，这是const的特例，很少出现        |
    | `const`  | 表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如：将主键置于where列表中，MySQL就能将该查询转换为一个常量 |
    | `eq_ref` | 唯一性索引扫描，对于每个索引键，`表中只有一条记录与之匹配`。常见于主键或唯一索引扫描 |
    | `ref`    | 非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，**它可能会找到多个符合条件的行**，所以它应该**属于查找和扫描的混合体** |
    | `range`  | 只检索给定范围的行，使用一个索引来选择行。`key`列显示使用了哪个索引。一般就是where语句中出现了between, <, >, in等的查询。 这种范围扫描索引比全表扫描要好，因为他只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。 |
    | `index`  | **Full Index Scan**，index与ALL的区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。(也就是说虽然**index和ALL都是读全表**，但是index是从索引中读取，而all是从硬盘中读的) |
    | `all`    | **Full Table Scan**，将遍历全表来找到匹配的行                |

  - **possible_key**: 显示可能应用在这张表的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但**不一定被实际查询使用**。

  - **key**: 实际使用的索引。如果为NULL，则没有使用索引。*查询中若使用了`覆盖索引`，则该索引仅出现在key列表中。*即where后面的查询字段顺序和建立复合索引的一致，此时`possible_key` 是NULL，而`key`不是NULL。

    > **覆盖索引**(Covering Index): 
    >
    > ![1619528855761](../../media/1619528855761.png)

    

    ![1619525900609](../../media/1619525900609.png)

  - **key_len**: 表示索引中使用的字节数，可以通过该列计算查询中使用的索引的长度。**在不损失精确性的情况下，长度越短约好**。`key_len`显示的值为索引字段的最大可能长度，**并非实际使用长度**，即`key_len`是*根据表定义计算而得，不是通过表内检索出的*。

    ![1619526542784](../../media/1619526542784.png)

  - **ref**: 显示索引的哪一列被使用了，如果可能的话，最好是一个常量。哪些列或常量被用于查找索引列上的值

    ![1619526887640](../../media/1619526887640.png)

  - **rows**: 根据表统计信息及索引选用情况，大致估算出找到所需记录所需要读取的行数。

  - **Extra**: 包含不适合在其他列中显示但十分重要的信息。有如下几种:

    - :name_badge:**Using filesort**(文件内排序): 说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为"文件排序"。 ---- [需要进行SQL优化]()

      ![1619527778531](../../media/1619527778531.png)

    - :no_entry:**Using Temporary**: 使用了临时表保存中间结果，**MySQL在对查询结果排序是使用临时表**。常见于order by和分组查询group by。 --- [奇慢无比，需要优化](建临时表要花性能和空间，用完删掉也耗费性能)

      ![1619528246857](../../media/1619528246857.png)

      

      

    - :+1:**Using index**: 表示相应的select操作中使用了`覆盖索引`(Covering Index), 避免访问了表的数据行，效率不错! 如果同时出现`using where`，表明索引被用来执行索引键值的查找；如果没有同时出现`using where`，表明索引用来读取数据而非执行查找动作。

      > **覆盖索引**(Covering Index): 
      >
      > ![1619528855761](../../media/1619528855761.png)

    - **Using where**: 表明使用了where过滤

    - **Using join buffer**: 使用了连接缓存

    - **impossible where**: where 子句的值总是false，不能用来获取任何元组

    - > (不太常见和重要)**select table optimized away**: 在没有group by的情况下，基于索引优化min/max操作或者对于MyISAM存储引擎优化count(*)操作，不必等到执行阶段再进行计算，查询执行计划生成阶段即完成优化

    - > **distinct**: 优化distinct操作，在找到第一匹配的元组后立即停止找同样值的操作

- 作用:

  | conlumn_name   | 作用                                                         |
  | -------------- | ------------------------------------------------------------ |
  | `id`           | 表的读取顺序(优化原则:**小表优先大表**,尽量让数据量小的表先执行) |
  | `select_type`  | 数据读取操作的操作类型                                       |
  | `possible_key` | 哪些索引可以使用                                             |
  | `key`          | 哪些索引被实际使用                                           |
  | `ref`          | 表之间的引用                                                 |
  | `rows`         | 每张表有多少行被优化器查询                                   |


###### E. SQL 优化

1. 联合索引: 最左原则，范围后失效原则

2. join查询(小表驱动大表)：
   - left join: index最好建在右表(右表仅部分内容会被查到，而左表要全表扫描)，或者对调表的位置
   - right join: index最好建在左表,理由参考上面
   
3. order by关键字优化:

   - 尽量使用`Index`方式排序，避免使用`FileSort`方式排序.即要满足**最左前缀原则**

   - 如果不在索引列上，`FileSort`有两种算法:

     - **双路排序**: MySQL4.1之前是使用双路排序，字面意思就是**两次扫描磁盘**，最终得到数据。**第一次**，读取行指针和order by列，对它们进行排序。**第二次**，扫描已经排好序的列表，按照列表中的值重新读取对应的数据输出。简言之，先从磁盘读取排序字段，在内存中进行排序，再从磁盘中读取其它字段。IO耗时。

     - **单路排序**: 从磁盘中读取查询需要的**所有列**，按照order by列在buffer中对他们进行排序，然后扫描排序后的列表进行输出。(它的效率更快一些，避免了第二次读取数据，但是会使用更多的空间。***假如需要读取的数据量很大，而sort_buffer设置的不够大，就导致需要多次磁盘IO，性能反而可能会比双路排序更差。***)

       ![1619614523322](../../media/1619614523322.png)

       ![1619614627857](../../media/1619614627857.png)

   ![1619614999805](../../media/1619614999805.png)

   - group by关键字优化(基本同order by):

     ![1619615192128](../../media/1619615192128.png)

     

4. 索引失效(如何避免):

   ![1619609860695](../../media/1619609860695.png)

   :fire:解决like '%<String>%' 时索引不被使用的办法: 使用`覆盖索引`，且返回的字段都被index字段覆盖到。这样就可以走的是index([Full Index Scan][#Full Index Scan])

   ![1619612624202](../../media/1619612624202.png)

   ![1619612859455](../../media/1619612859455.png)

   

###### F. 慢SQL查询分析

1. 观察，至少一天，看看生产的慢SQL情况。

2. 开启慢SQL查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将其抓取出来。

   ![1619615306618](../../media/1619615306618.png)

   > [**日志分析工具mysqldumpslow**(MySQL自带的工具，可以直接在query shell中执行)]()

   ![1619617546874](../../media/1619617546874.png)

   ![1619617623289](../../media/1619617623289.png)

   

3. explain + 慢SQL分析(到这一步基本能解决80%的问题)

4. show profile: 查询SQL在MySQL服务器里面的执行细节和生命周期情况。(到这一步基本能解决90%的问题)

   ![1620135000052](../../media/1620135000052.png)

   ![1620135109269](../../media/1620135109269.png)

   ![1620135744227](../../media/1620135744227.png)

   ![1620135956899](../../media/1620135956899.png)

5. DBA进行SQL服务器的参数调优

#### 4. 锁机制

##### A. 锁的分类

###### Ⅰ. 对数据的操作层面分类

- **读锁(共享锁)**: 针对同一份数据，多个读操作可以同时进行而不会互相影响。即使时发起锁表的session1也不能改被锁的表(其它session2的写命令在此期间会一直阻塞，直到锁表的seesion1释放锁，session2执行)，且发起锁表的session1在没有释放锁之前，不可以操作其他表。
- **写锁(排它锁)**: 当前写操作没有完成前，会阻断其它写锁或读锁。发起锁表的session1可以读，写被锁的表。其它session2对该锁定表的读写命令都会被阻塞，直到锁被释放。

![1620137934823](../../media/1620137934823.png)

![1620137994883](../../media/1620137994883.png)

![1620138104272](../../media/1620138104272.png)



###### Ⅱ. 对数据操作的粒度分类

- **表锁(偏读)**

- **行锁(偏写)**: 偏向InnoDB存储引擎，枷锁慢，开销大；会出现死锁；锁定粒度最小；发生冲突的概率最低，并发度最高。InnoDB与MyISAM的最大不同有两点: 一是支持事务(TRANSACTION)；二是支持行锁。

  ![1620138595747](../../media/1620138595747.png)

  ![1620138766174](../../media/1620138766174.png)

  235

- 分段锁



