# 2：Basic Knowledge of Class Loading-Ⅱ

## Ⅰ. 查看字节码文件

- [Jclasslib - 查看字节码的插件，在IDEA中可直接安装][]

![1576155897876](../../media/1576155897876.png)



![1576068450922](../../media/1576068450922.png)

![1576068704487](../../media/1576068704487.png)

![1576068927171](../../media/1576068927171.png)



1. 使用**javap -verbose**命令分析一个字节码文件时，将会得到该字节码文件的`魔数`、`版本号`、`常量池`、`类信息`、`类的构造方法`、`类中的方法信息`、`类变量`与`成员变量`等信息。

   (当成员变量或方法为private时，需要额外加上-p(**javap -verbose -p**)参数才会显示，否则会隐藏)

![1575464432398](../../media/1575464432398.png)

![1575464474864](../../media/1575464474864.png)

> ### 1.`魔数`： 所有的.class字节码文件的前四个字节都是魔数，魔数值为固定值：0xCAFEBABE。如果不是，JVM会 拒绝加载。

> ### 2. `版本信息`：魔数之后的四个字节是版本信息，前连个字节是 minor version（**次版本号**），后两个字节是major versio（**主版本号**）。这里的版本号为00 00 00 34,换算成十进制表示，次版本号为0，主版本号为52.所以该文件的版本号为：1.8.0（1.8来自主版本号52对应的jdk8，jdk7为51，以此类推,0来自次版本号0）可以通过java -version 来验证这一点。

![1575980236202](../../media/1575980236202.png)



> ### 3. `常量池（constant pool）`：紧接着版本信息之后的就是常量池入口。一个java类中定义的很多信息都是由常来维护和描述的，我们可以将常量池看作是Class文件的**资源仓库**，比如说java类中定义的方法和变量信息。常量池中主要存储两类常量：字面量和符号引用（[不一定都是常量，也可以是变量]()）
>
> > 					- 字面量： 如字符串，java中声明为final的常量值等
> > 					- 符号引用：如类和接口的全限定名，字段的名称和描述符，方法的名称和描述符等。
>
> `常量池的总体结构`：java类所对应的常量池主要由**常量池数量**和**常量池数组**两部分组成。
>
> > - `常量池数量`紧跟在主版本后面，占据**2个字节**
> > - `常量池数组`（常量表）紧跟在常量池数量之后，常量池数组与一般数组不同的是，[常量池数组中不同元素的类型、结构都是不同的，字节长度也因此不同]()；但是，每一种元素的第一个数据都是一个u1类型，该字节是个标志位，占据**1个字节**，JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。值得注意的是，常量池中元素的***个数= 常量池数 - 1*** （其中0暂时不使用）。[目的是满足某些常量池索引值的数据在特定情况下需要表达【不引用任何一个常量池】的含义；根本原因在于，索引值0也是一个常量（JVM保留常量），只不过它不位于常量表中，这个常量值就对应null值；所以常量池的索引从1而非0开始。]()

###### 对于基本数据类型，JVM都只使用一个大写字母来表示：

- **B** - byte
- **C** - char
- **D** - double
- **F** - float
- **I** - int
- **J** - long
- **S** - short
- **Z** - boolean
- **V** - void
- **L** - 对象类型，如Ljava/lang/String

###### 对于数组类型来说，每一个维度使用一个前置的[来表示，如:

- **int[]** - [I
- **String\[ ][ ]** - [[Ljava/lang/String

###### 用描述符描述方法时，按照先参数列表，后返回值的顺序来描述，参数列表按照参数的严格顺序放在一组()内：

- **String getName(int id, String name)** - (I, Ljava/lang/String;) Ljava/lang/String

> ### 4. `Access_Flag` 访问标志
<<<<<<< Updated upstream
>

> ### 5. Fields_count 字段表

> ### 6. Methods_count 方法表
>
> ![1587997319151](E:\Typora\Typora_Note\media\1587997319151.png)
>
> 
>
> --43
=======



> ### 5. 方法表（Methods）

### 6. synchronized 关键字

`a. no synchronized`

```java
public class test4 {
    private int a = 1;

    public int getA() {
        return a;
    }

    private void setA(int a) {
        this.a = a;
    }
}
```

```linux
javap -verbose -p test4.class
```

![1577709843283](../../media/1577709843283.png)

`b. synchronized for method` 

​	加锁（moniterenter）和释放锁(moniterexit)的命令未显示出来, **对this对象上锁**

![1577709876729](../../media/1577709876729.png)

`c. synchronized for object`

```java
public class test4 {
    private int a = 1;

    private Object object;
    public int getA() {
        return a;
    }

    private synchronized void setA(int a) {
        this.a = a;
    }

    private void test(String s){
        synchronized (object){
            System.out.println("hello");
        }
    }
}
```

![1577710875597](../../media/1577710875597.png)

`c. synchronized for static method`

**给当前对象所对应的类对象上锁**

```java
public class test4 {
    private int a = 1;

    private Object object;
    public int getA() {
        return a;
    }

    private synchronized void setA(int a) {
        this.a = a;
    }

    private void test(String s){
        synchronized (object){
            System.out.println("hello");
        }
    }

    private static synchronized void test2(){
        System.out.println("hhh");
    }
}
```

![1577711225757](../../media/1577711225757.png)



### 7. 静态变量和静态代码快

静态变量和静态代码快最终都会**按顺序**被放置到<clinit>方法中

![1578314802005](../../media/1578314802005.png)



### 8. this关键字及异常表的作用

> code:

![1589376611242](../../media/1589376611242.png)



**This 关键字: ** 对于Java类中的每一个实例方法(非static，static方法或者参数是从属于当前类所对应的`class对象`					  **而非**`当前对象`)，其在编译后所生成的字节码当中，方法参数的数量总是会比源代码方法参数的数量多					    一个，**它位于方法的第一个参数位置**；这样，我们就可以通过this来访问当前对象的属性以及其他方				        法。

​						**这个操作是在编译期完成的**，即由javac编译期在编译期对this的访问转化为一个普通实例方法参						数的访问；接下来在运行期，由JVM在调用实例方法时，自动向实例方法传入该参数。所以在实例方						法的局部变量表中，至少会有一个指向当前对象的局部变量。

![1589376033069](../../media/1589376033069.png)



![1589376244335](../../media/1589376244335.png)



### 9. Exception_table 异常处理机制

![1589377627933](../../media/1589377627933.png)



![1589377734453](../../media/1589377734453.png)



![1589377571748](../../media/1589377571748.png)

> **1.  catach_type #0的异常是`编译器`自动生成出来，目的是处理代码中所定义的异常处理不了的异常。**
>
> **2. 当异常处理存在finally语句块时，现代化的JVM采取的处理方式是将finally语句块的字节码拼接到每一个catch块后面。即程序中存在多少个catch字节码块，就会跟着有多少个finally字节码块。**
>
> > -  *编译器编译出来的字节码用的是goto跳转，而JVM采用重复的方式来减少跳转*
> > - *catch_type0也会为其拼接finally代码块，因此上面这个例子会重复4个finally代码块。也就是说如果有异常没有被catch到，会被catch_type0捕获，也会走finally,验证如下：*

``` groovy
class TestException {
    void test1(){
        try {
            FileInputStream stream = new FileInputStream("notExist.txt")
        }catch(NullPointerException e){
            println("NullPointerException")
        }finally{
            println("app stop")
        }
    }

    public static void main(String[] args) {
        TestException test = new TestException()
        test.test1()
    }
}
```

![1589465280012](../../media/1589465280012.png)

当把异常抛出时，字节码文件会增加多`Exceptionsxs`信息

![1589465764097](../../media/1589465764097.png)



- 51

